package com.opal.creator.database;

import java.util.Set;

import org.apache.commons.lang3.Validate;

public class ForeignKey {
	
	/* The Key (essentially, list of columns/fields) in the referencing table. */
	private final Key mySourceKey;
	
	/* The Key (list of columns/fields) in the referenced table. */
	private final Key myTargetKey;
	
	/* The name of the foreign key.  This is likely some unreadable string generated by the database. */
	private final String myName;
	
	/* The action to take on delete.  For instance, CASCADE.  Opal currently doesn't do anything with this. */	
	private final ReferentialAction myDeleteAction;
	private final ReferentialAction myUpdateAction;
	
	/* The standard prefix to apply to the generated methods that make use of the foreign key in the referencing object. */
	private String mySourceRolePrefix;
	
	/* The standard prefix to apply to the generated methods that make use of the foreign key in the referenced object.
	 * For instance, if this is "Xyzzy" for a key from table "Person" to "City," then the City interface will have a method
	 * createXyzzyPersonIterator.
	 */
	private String myTargetRolePrefix;
	
	/* The Java-level access modifier for the methods relating to this foreign key on the referencing table.  Almost always "public". */	
	private String mySourceAccess;
	
	/* The Java-level access modifier for the methods relating to this foreign key on the referenced table.  Almost always "public". */
	private String myTargetAccess;
	
	private String myJoinQueryFactoryName;
	
	private boolean myOneToOne;
	
	private Class<?> myCollectionClass;
	private boolean myCollectionClassSpecified;
	
	private boolean myMapped = true;

	private String mySpecifiedBaseName; // null means generate and use the default
	private String mySpecifiedCollectionItemName; // null means generate and use the default
	private String mySpecifiedCollectionName; // null means generate and use the default
	
	private String mySpecifiedSourceBaseName; // null means generate and use the default
	private String mySpecifiedTargetBaseName; // null means generate and use the default
	
	public static final Class<?> USE_DEFAULT_COLLECTION_CLASS = Set.class;
	
	public ForeignKey(Key argSourceKey, Key argTargetKey, String argName, ReferentialAction argDeleteAction, ReferentialAction argUpdateAction) {
		this(argSourceKey, argTargetKey, argName, argDeleteAction, argUpdateAction, null, null, null, null, null, false, USE_DEFAULT_COLLECTION_CLASS, null, null, null, true);
	}
	
	public ForeignKey(
		Key argSourceKey,
		Key argTargetKey,
		String argName,
		ReferentialAction argDeleteAction,
		ReferentialAction argUpdateAction,
		String argSourceRolePrefix,
		String argTargetRolePrefix,
		String argSourceAccess,
		String argTargetAccess,
		String argJoinSQL,
		boolean argOneToOne,
		Class<?> argCollectionClass,
		String argSpecifiedBaseName,
		String argSpecifiedCollectionItemName,
		String argSpecifiedCollectionName,
		boolean argMapped
	) {
		super();
		
		Validate.notNull(argSourceKey);
		mySourceKey = argSourceKey;
		
		Validate.notNull(argTargetKey);
		myTargetKey = argTargetKey;
		
		Validate.notNull(argName);
		myName = argName;
		
		myDeleteAction = Validate.notNull(argDeleteAction);
		myUpdateAction = Validate.notNull(argUpdateAction);
		
		mySourceRolePrefix = argSourceRolePrefix; // Can be null
		
		myTargetRolePrefix = argTargetRolePrefix; // Can be null
		
		mySourceAccess = argSourceAccess; // Can be null
		
		myTargetAccess = argTargetAccess; // Can be null
		
		myJoinQueryFactoryName = argJoinSQL; // Can be null
		
		myOneToOne = argOneToOne;
		
		if (myOneToOne) {
			myCollectionClass = null;
			myCollectionClassSpecified = true;
//			System.out.println("ForeignKey created for manually marked one-to-one key.");
		} else {
			myCollectionClass = argCollectionClass; // Can be null
			if (myCollectionClass != USE_DEFAULT_COLLECTION_CLASS) {
				myCollectionClassSpecified = true;
			}
		}
		
		mySpecifiedBaseName = argSpecifiedBaseName;
		
		mySpecifiedCollectionItemName = argSpecifiedCollectionItemName;
		mySpecifiedCollectionName = argSpecifiedCollectionName;
		
		myMapped = argMapped;
	}
	
	public ReferentialAction getDeleteAction() {
		return myDeleteAction;
	}
	
	public ReferentialAction getUpdateAction() {
		return myUpdateAction;
	}
	
	public String getName() {
		return myName;
	}
	
	public Key getSourceKey() {
		return mySourceKey;
	}
	
	public boolean isRequired() {
		return getSourceKey().isRequired();
	}
	
	public Key getTargetKey() {
		return myTargetKey;
	}
	
	public String getSourceRolePrefix() {
		return mySourceRolePrefix;
	}
	
	public String getTargetRolePrefix() {
		return myTargetRolePrefix;
	}
	
	public String getSourceAccess() {
		return mySourceAccess;
	}
	
	public String getTargetAccess() {
		return myTargetAccess;
	}
	
	public void setTargetAccess(String argTargetAccess) {
		myTargetAccess = argTargetAccess;
	}
	
	public void setSourceAccess(String argSourceAccess) {
		mySourceAccess = argSourceAccess;
	}
	
	public void setSourceRolePrefix(String argSourceRolePrefix) {
		mySourceRolePrefix = argSourceRolePrefix;
	}
	
	public void setTargetRolePrefix(String argTargetRolePrefix) {
		myTargetRolePrefix = argTargetRolePrefix;
	}
	
	public String getJoinQueryFactoryName() {
		return myJoinQueryFactoryName;
	}
	
	public void setJoinQueryFactoryName(String argJoinQueryFactoryName) {
		myJoinQueryFactoryName = argJoinQueryFactoryName;
	}
	
	public Class<?> getCollectionClass() {
		return myCollectionClass;
	}
	
	public void setCollectionClass(Class<?> argCollectionClass) {
		myCollectionClass = argCollectionClass;
		myCollectionClassSpecified = true;
	}
	
	public boolean isCollectionClassSpecified() {
		return myCollectionClassSpecified;
	}
	
	public boolean isSetToUseDefaultCollectionClass() {
		return myCollectionClass == USE_DEFAULT_COLLECTION_CLASS;
	}
	
	@Override
	public String toString() {
		return getName() + '[' + getSourceKey() + "->" + getTargetKey() + ']';
	}
	
	public boolean isMapped() {
		return myMapped;
	}
	
	public void setMapped(boolean argMapped) {
		myMapped = argMapped;
	}
	
	public String getSpecifiedBaseName() {
		return mySpecifiedBaseName;
	}
	
	public void setSpecifiedBaseName(String argSpecifiedBaseName) { // The argument might be null.
		mySpecifiedBaseName = argSpecifiedBaseName;
	}
	
	public String getSpecifiedCollectionName() {
		return mySpecifiedCollectionName;
	}
	
	public void setSpecifiedCollectionName(String argSpecifiedCollectionName) { // The argument might be null.
		mySpecifiedCollectionName = argSpecifiedCollectionName;
	}
	
	public String getSpecifiedCollectionItemName() {
		return mySpecifiedCollectionItemName;
	}
	
	public void setSpecifiedCollectionItemName(String argSpecifiedCollectionItemName) { // The argument might be null.
		mySpecifiedCollectionItemName = argSpecifiedCollectionItemName;
	}
	
	public String getSpecifiedSourceBaseName() {
		return mySpecifiedSourceBaseName;
	}
	
	public void setSpecifiedSourceBaseName(String argSpecifiedSourceBaseName) { // The argument might be null.
		mySpecifiedSourceBaseName = argSpecifiedSourceBaseName;
	}
	
	public String getSpecifiedTargetBaseName() {
		return mySpecifiedTargetBaseName;
	}
	
	public void setSpecifiedTargetBaseName(String argSpecifiedTargetBaseName) { // The argument might be null.
		mySpecifiedTargetBaseName = argSpecifiedTargetBaseName;
	}
	
	public boolean isOneToOne() {
		return myOneToOne;
	}
	
	public void setOneToOne(boolean argOneToOne) {
		myOneToOne = argOneToOne;
	}
}
